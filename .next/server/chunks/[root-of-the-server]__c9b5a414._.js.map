{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n\n\n/*\n\n@t3-oss/env-nextjs: A wrapper utility from the T3 stack that helps validate environment variables in both server and client contexts.\n\nzod: A schema validation library used here to define what each environment variable should look like.\n\n*/"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,+KAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,+KAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B,IAGA;;;;;;AAMA","debugId":null}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"@/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,6HAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;YAAS;SAAO,GAAG;YAAC;SAAQ;IAC3E;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/server/api/trpc.ts"],"sourcesContent":["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\nimport { initTRPC } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\nimport {TRPCError} from \"@trpc/server\";\n\nimport { db } from \"@/server/db\";\nimport { auth } from \"@clerk/nextjs/server\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n *\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\n * wrap this and provides the required context.\n *\n * @see https://trpc.io/docs/server/context\n */\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\n  return {\n    db,\n    ...opts,\n  };\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * Create a server-side caller.\n *\n * @see https://trpc.io/docs/server/server-side-calls\n */\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Middleware for timing procedure execution and adding an artificial delay in development.\n *\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\n * network latency that would occur in production but not in local development.\n */\nconst isAuthenticated = t.middleware(async ({ next, ctx }) => {\n  const user = await auth()\n\n\n  if (!user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You must be logged in to access this resource'\n    })\n  }\n\n  // If user exists, continue and pass user to context\n  return next({\n    ctx: {\n      ...ctx,\n      user,\n    }\n  });\n}); // MIDDLEWARE FUNCTIONS WHICH TELLS TRPC ROUTER WHETHER THE USER IS AUTHENTICATED OR NOT \n\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\n\n  return result;\n});\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\nexport const protectedProcedure = t.procedure.use(isAuthenticated);"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;;AACD;AACA;AACA;AACA;AAEA;AACA;;;;;;;AAcO,MAAM,oBAAoB,OAAO;IACtC,OAAO;QACL,IAAA,qHAAA,CAAA,KAAE;QACF,GAAG,IAAI;IACT;AACF;AAEA;;;;;;CAMC,GACD,MAAM,IAAI,mKAAA,CAAA,WAAQ,CAAC,OAAO,GAA6B,MAAM,CAAC;IAC5D,aAAa,4IAAA,CAAA,UAAS;IACtB,gBAAe,EAAE,KAAK,EAAE,KAAK,EAAE;QAC7B,OAAO;YACL,GAAG,KAAK;YACR,MAAM;gBACJ,GAAG,MAAM,IAAI;gBACb,UACE,MAAM,KAAK,YAAY,gJAAA,CAAA,WAAQ,GAAG,MAAM,KAAK,CAAC,OAAO,KAAK;YAC9D;QACF;IACF;AACF;AAOO,MAAM,sBAAsB,EAAE,mBAAmB;AAcjD,MAAM,mBAAmB,EAAE,MAAM;AAExC;;;;;CAKC,GACD,MAAM,kBAAkB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE;IACvD,MAAM,OAAO,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAGtB,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,kKAAA,CAAA,YAAS,CAAC;YAClB,MAAM;YACN,SAAS;QACX;IACF;IAEA,oDAAoD;IACpD,OAAO,KAAK;QACV,KAAK;YACH,GAAG,GAAG;YACN;QACF;IACF;AACF,IAAI,yFAAyF;AAE7F,MAAM,mBAAmB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACzD,MAAM,QAAQ,KAAK,GAAG;IAEtB,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;QACnB,0BAA0B;QAC1B,MAAM,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,OAAO;QACjD,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACrD;IAEA,MAAM,SAAS,MAAM;IAErB,MAAM,MAAM,KAAK,GAAG;IACpB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,MAAM,aAAa,CAAC;IAE7D,OAAO;AACT;AASO,MAAM,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC;AACxC,MAAM,qBAAqB,EAAE,SAAS,CAAC,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/server/api/routers/post.ts"],"sourcesContent":["import { z } from \"zod\";\n\nimport { createTRPCRouter, publicProcedure } from \"@/server/api/trpc\";\n\nexport const postRouter = createTRPCRouter({\n  hello: publicProcedure\n    .input(z.object({ text: z.string() }))\n    .query(({ input }) => {\n      return {\n        greeting: `Hello ${input.text}`,\n      };\n    }),\n\n  create: publicProcedure\n    .input(z.object({ name: z.string().min(1) }))\n    .mutation(async ({ ctx, input }) => {\n      return ctx.db.post.create({\n        data: {\n          name: input.name,\n        },\n      });\n    }),\n\n  getLatest: publicProcedure.query(async ({ ctx }) => {\n    const post = await ctx.db.post.findFirst({\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return post ?? null;\n  }),\n});\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEO,MAAM,aAAa,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,OAAO,8HAAA,CAAA,kBAAe,CACnB,KAAK,CAAC,+KAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAAE,MAAM,+KAAA,CAAA,IAAC,CAAC,MAAM;IAAG,IAClC,KAAK,CAAC,CAAC,EAAE,KAAK,EAAE;QACf,OAAO;YACL,UAAU,CAAC,MAAM,EAAE,MAAM,IAAI,EAAE;QACjC;IACF;IAEF,QAAQ,8HAAA,CAAA,kBAAe,CACpB,KAAK,CAAC,+KAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAAE,MAAM,+KAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IAAG,IACzC,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC;YACxB,MAAM;gBACJ,MAAM,MAAM,IAAI;YAClB;QACF;IACF;IAEF,WAAW,8HAAA,CAAA,kBAAe,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE;QAC7C,MAAM,OAAO,MAAM,IAAI,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC;YACvC,SAAS;gBAAE,WAAW;YAAO;QAC/B;QAEA,OAAO,QAAQ;IACjB;AACF","debugId":null}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/lib/github.ts"],"sourcesContent":["import { db } from '@/server/db';\r\nimport { Octokit } from 'octokit';\r\nimport axios from 'axios';\r\nimport { aiSummariseCommit } from './gemini';\r\n\r\nexport const octokit = new Octokit({\r\n    auth: process.env.GITHUB_TOKEN,\r\n});\r\n\r\nconst githubUrl = 'https://github.com/docker/genai-stack';\r\n\r\ntype Response = {\r\n    commitHash: string;\r\n    commitMessage: string;\r\n    commitAuthorName: string;\r\n    commitAuthorAvatar: string;\r\n    commitDate: string;\r\n}\r\n\r\nexport const getCommitHashes =async (githubUrl: string): Promise<Response[]> => {\r\n    // https://github.com/docker/genai-stack\r\n    const [owner, repo] = githubUrl.split('/').slice(-2)\r\n    if(!owner || !repo) {\r\n        throw new Error('Invalid GitHub URL');\r\n    }\r\n    const { data } = await octokit.rest.repos.listCommits({\r\n        owner,\r\n        repo\r\n        \r\n    });\r\n    const sortedCommits = data.sort((a: any, b: any) => new Date(b.commit.author.date).getTime() - new Date(a.commit.author.date).getTime()) as any[];\r\n\r\n    return sortedCommits.slice(0, 10).map((commit: any) => ({\r\n        commitHash: commit.sha as string,\r\n        commitMessage: commit.commit.message ?? \"\",\r\n        commitAuthorName: commit.commit?.author?.name ?? \"\",\r\n        commitAuthorAvatar: commit.author?.avatar_url ?? \"\",\r\n        commitDate: commit.commit?.author?.date ?? \"\",\r\n    }))\r\n}\r\n\r\n// console.log(await getCommitHashes(githubUrl))\r\n\r\nexport const pollCommits = async (projectId: string) => {\r\n    const {project, githubUrl} = await fetchProjectGithubUrl(projectId)\r\n    const commitHashes = await getCommitHashes(githubUrl)\r\n    const unprocessedCommits = await filterUnprocessedCommits(projectId, commitHashes);\r\n    const summaryResponses = await Promise.allSettled(unprocessedCommits.map(commit => {\r\n        return summariseCommit(githubUrl,commit.commitHash)\r\n    })) \r\n\r\n    //console.log(unprocessedCommits);\r\n\r\n    const summaries = summaryResponses.map((response) => { \r\n        if (response.status === 'fulfilled') {\r\n            return response.value as string\r\n        }\r\n        return \"\"\r\n    })\r\n\r\n    const commits = await db.commit.createMany({\r\n        data: summaries.map((summary, index) => {\r\n            console.log(`processing commit ${index}`);\r\n            return {\r\n                projectId: projectId,\r\n                commitHash: unprocessedCommits[index]!.commitHash,\r\n                commitMessage: unprocessedCommits[index]!.commitMessage,\r\n                commitAuthorName: unprocessedCommits[index]!.commitAuthorName,\r\n                commitAuthorAvatar: unprocessedCommits[index]!.commitAuthorAvatar,\r\n                commitDate: unprocessedCommits[index]!.commitDate,\r\n                summary\r\n            }\r\n        })\r\n    })\r\n\r\n    return commits\r\n    \r\n}\r\n\r\n// FUNCTION TO GENERATE SUMMARY\r\n/*\r\nasync function summariseCommit(githubUrl: string, commitHash: string){\r\n    // get the diff, then pass the diff into ai\r\n    const { data } = await axios.get(`${githubUrl}/commit/${commitHash},diff`, {\r\n        headers: {\r\n            Accept: 'application/vnd.github.v3.diff',\r\n        }\r\n    })\r\n    return await aiSummariseCommit(data) || \"\"\r\n}\r\n*/\r\n\r\nasync function summariseCommit(githubUrl: string, commitHash: string) {\r\n    const { data } = await axios.get(\r\n  `https://api.github.com/repos/${owner}/${repo}/commits/${commitHash}`,\r\n  {\r\n    headers: {\r\n      Accept: 'application/vnd.github.v3.diff', // This returns the actual diff string\r\n      Authorization: `Bearer ${process.env.GITHUB_TOKEN}`\r\n    },\r\n    responseType: 'text' // <- This is important! Otherwise axios might try to parse it\r\n  }\r\n);\r\n}\r\n\r\n\r\n\r\nasync function fetchProjectGithubUrl(projectId: string) {\r\n    const project = await db.project.findUnique({\r\n        where: {id: projectId},\r\n        select: {\r\n            githubUrl: true\r\n        }\r\n    })\r\n    if(!project?.githubUrl) {\r\n        throw new Error('Project does not have a GitHub URL');\r\n    }\r\n    return { project, githubUrl: project?.githubUrl };    \r\n}\r\n\r\nasync function filterUnprocessedCommits(projectId: string, commitHashes: Response[]) {\r\n    const processedCommits = await db.commit.findMany({\r\n        where: { projectId }\r\n    })    \r\n        \r\n    const unprocessedCommits = commitHashes.filter((commit) => !processedCommits.some((processedCommit) => processedCommit.commitHash === commit.commitHash));\r\n\r\n    return unprocessedCommits\r\n}\r\n\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/server/api/routers/project.ts"],"sourcesContent":["import {z} from \"zod\";\r\nimport { createTRPCRouter, protectedProcedure } from \"../trpc\";\r\nimport { pollCommits } from \"@/lib/github\";\r\n\r\nexport const  projectRouter = createTRPCRouter({\r\n  createProject: protectedProcedure.input(\r\n    z.object({\r\n        name: z.string(),\r\n        githubUrl: z.string(),\r\n        githubToken: z.string().optional()\r\n    })\r\n  ).mutation(async ({ ctx, input }) => {\r\n\r\n    // project is prima model\r\n    const project = await ctx.db.project.create({ \r\n        data: {\r\n            githubUrl: input.githubUrl,\r\n            name: input.name,\r\n            userToProjects: {\r\n                create: {\r\n                    userId: ctx.user.userId!, // ! since I am sure ctx.user.userId is not null or undefined here.\r\n                }\r\n            }\r\n        }\r\n        \r\n    })\r\n    await pollCommits(project.id) // Poll commits for the project\r\n    return project\r\n    \r\n    //console.log('input', input)\r\n    //return true\r\n  }),\r\n\r\n  // PROTECTEDPROCEDURE SINCE I ONLY LOGIN ANDONLY I WNAT TO KNOW THE PROJECTS\r\n  getProjects: protectedProcedure.query(async ({ ctx }) => {\r\n    return await ctx.db.project.findMany({\r\n        where: {\r\n            userToProjects: {\r\n                some: { // some means Only include projects where at least one UserToProject entry exists with this userId\r\n                    userId: ctx.user.userId!,\r\n                }\r\n            },\r\n            deletedAt: null // If deletedAt has a timestamp (new Date()), it means the item was \"soft deleted\". // This lets you \"hide\" items without removing them from the database.\r\n        }\r\n    })\r\n  }),\r\n  getCommits: protectedProcedure.input(z.object({\r\n    projectId: z.string()\r\n  })).query(async ({ ctx, input }) => {\r\n    pollCommits(input.projectId).then().catch(console.error)\r\n    return await ctx.db.commit.findMany({ where: { projectId: input.projectId} })\r\n    })\r\n})\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEO,MAAO,gBAAgB,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IAC7C,eAAe,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CACrC,+KAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACL,MAAM,+KAAA,CAAA,IAAC,CAAC,MAAM;QACd,WAAW,+KAAA,CAAA,IAAC,CAAC,MAAM;QACnB,aAAa,+KAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IACpC,IACA,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAE9B,yBAAyB;QACzB,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC;YACxC,MAAM;gBACF,WAAW,MAAM,SAAS;gBAC1B,MAAM,MAAM,IAAI;gBAChB,gBAAgB;oBACZ,QAAQ;wBACJ,QAAQ,IAAI,IAAI,CAAC,MAAM;oBAC3B;gBACJ;YACJ;QAEJ;QACA,MAAM,CAAA,GAAA,sHAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,EAAE,GAAE,+BAA+B;QAC7D,OAAO;IAEP,6BAA6B;IAC7B,aAAa;IACf;IAEA,4EAA4E;IAC5E,aAAa,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE;QAClD,OAAO,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC;YACjC,OAAO;gBACH,gBAAgB;oBACZ,MAAM;wBACF,QAAQ,IAAI,IAAI,CAAC,MAAM;oBAC3B;gBACJ;gBACA,WAAW,KAAK,0JAA0J;YAC9K;QACJ;IACF;IACA,YAAY,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,+KAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC5C,WAAW,+KAAA,CAAA,IAAC,CAAC,MAAM;IACrB,IAAI,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC7B,CAAA,GAAA,sHAAA,CAAA,cAAW,AAAD,EAAE,MAAM,SAAS,EAAE,IAAI,GAAG,KAAK,CAAC,QAAQ,KAAK;QACvD,OAAO,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC;YAAE,OAAO;gBAAE,WAAW,MAAM,SAAS;YAAA;QAAE;IAC3E;AACJ","debugId":null}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/server/api/root.ts"],"sourcesContent":["import { postRouter } from \"@/server/api/routers/post\";\nimport { createCallerFactory, createTRPCRouter } from \"@/server/api/trpc\";\nimport { projectRouter } from \"./routers/project\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  post: postRouter,\n  project: projectRouter // FROM PROJECT.TS\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create a server-side caller for the tRPC API.\n * @example\n * const trpc = createCaller(createContext);\n * const res = await trpc.post.all();\n *       ^? Post[]\n */\nexport const createCaller = createCallerFactory(appRouter);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAOO,MAAM,YAAY,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACxC,MAAM,yIAAA,CAAA,aAAU;IAChB,SAAS,6IAAc,kBAAkB;IAAhC,CAAA,gBAAa;AACxB;AAYO,MAAM,eAAe,CAAA,GAAA,8HAAA,CAAA,sBAAmB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 598, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projects/github-chatbot/src/app/api/trpc/%5Btrpc%5D/route.ts"],"sourcesContent":["import { fetchRequestHandler } from \"@trpc/server/adapters/fetch\";\nimport { type NextRequest } from \"next/server\";\n\nimport { env } from \"@/env\";\nimport { appRouter } from \"@/server/api/root\";\nimport { createTRPCContext } from \"@/server/api/trpc\";\n\n/**\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\n * handling a HTTP request (e.g. when you make requests from Client Components).\n */\nconst createContext = async (req: NextRequest) => {\n  return createTRPCContext({\n    headers: req.headers,\n  });\n};\n\nconst handler = (req: NextRequest) =>\n  fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req,\n    router: appRouter,\n    createContext: () => createContext(req),\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `❌ tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n            );\n          }\n        : undefined,\n  });\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;AAAA;AAGA;AACA;AACA;;;;;AAEA;;;CAGC,GACD,MAAM,gBAAgB,OAAO;IAC3B,OAAO,CAAA,GAAA,8HAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,SAAS,IAAI,OAAO;IACtB;AACF;AAEA,MAAM,UAAU,CAAC,MACf,CAAA,GAAA,yKAAA,CAAA,sBAAmB,AAAD,EAAE;QAClB,UAAU;QACV;QACA,QAAQ,8HAAA,CAAA,YAAS;QACjB,eAAe,IAAM,cAAc;QACnC,SACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBACb,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;YACd,QAAQ,KAAK,CACX,CAAC,iBAAiB,EAAE,QAAQ,YAAY,EAAE,EAAE,MAAM,OAAO,EAAE;QAE/D,IACA;IACR","debugId":null}}]
}